\chapter{The \FRAMEWORK}
\thispagestyle{plain}

\label{Framework}

% What does the framework do? It build meta-models that map between agent-level and system-level.
% It frames the mapping problem into the forward mapping and the reverse mapping
% Uses a pluggable regression algorithm to solve these mapping problems

\section{Design Goals of The \framework}

% Our specific goals: provide insight and more intuitive control to agent-based models with a approach that is domain independent, algorithm independent, accurate and fast for the user.
My specific goal in designing \fw is to make controlling and interacting with agent-based models more intuitive.
In addition to this central goal, \fw strives to be:
\begin{itemize}
  \item Domain independent -- the design of \fw should minimize the amount of configuration for each domain,
  \item Algorithm independent -- any regression algorithm should be able to be plugged into \fw,
  \item Accurate -- \fw should generate accurate predictions and control suggestions,
  \item Fast for the user -- interactions with the models generated by \fw should require minimal computational time.
\end{itemize}

% Domain independence is important because the variety in which ABMs come. We want the same general approach to work for a forest fire simulation, a boid flock or particle swarm optimization.
% Algorithm independence is important because different algorithms will model different domains better. Also, as new regression techniques are implemented in the future, they can be plugged in to increase the accuracy of \fw.
Domain independence is paramount because of the variety in which ABMs come.
I have designed \fw such that the same general approach would work for any ABM.
Also, I strove to minimize the amount of configuration needed to apply \fw to a new domain.
These constraints I have set on the design make \fw broadly applicable to a number of domains, without the need of in-depth domain knowledge.
To reinforce this claim, I have tested \fw on a number of diverse domains and used the same general approach for each.

Algorithm independence in a learning framework is important because different algorithms are more effective for modeling different agent-based models.
In general, the learning algorithms that will be discussed in this dissertation will satisfy the requirements for modeling most agent-based models.
However, an in depth analysis of which types of algorithms should be used for different classes of ABMs is outside the scope of this dissertation research.
In addition, algorithm independence allows \fw to scale with new advances in machine learning research, since future state-of the art regression algorithms can be plugged in just as easily as current approaches.

Accuracy and fast user response time appear to be obvious design goals.
However, \fw requires that the user spends a significant amount of computational time sampling different configurations of the target ABM.
These large training sets can be used to build static meta-models of ABMs that are both accurate and fast to query.
In contrast, an active learning approach would be able to learn models faster, but would require interaction with the user, increasing the amount of user interaction.
Likewise, optimization approaches could be used to generate arbitrarily accurate results, but typically require numerous iterations and would significantly increase the response time for a user's query.
In summary, I am making the assumption that users studying ABMs with \fw are more interested in achieving more accurate results for their research, than generating their results faster.
I discuss this trade off in more detail in Chapter \ref{ReverseMapping}: The Reverse Mapping Problem.



\section{Framework Structure}

% The framework is split into three phases and four major parts.
% Each phase feeds into the next
% Many configuration points exist in which users of \fw can change the way the framework works.
% However, no matter the configuration, the input and output of each phase is the same.

% Diagram  sampling ->  [ FM / RM ] -> usage tools

\subsection{Sampling}
% The first phase is sampling, in which the framework interacts with the agent-based model to generate a large enough data set for training.
   % Measurements have to be defined to tell what to sample.
   % Measurements must be stable (i.e., follow the laws of large numbers); they must converge over time
   % Wording of the measurement is important (give the example of wolves going extinct)

   % For this dissertation, we either use a random sampling method or a systematic sampling method
   % Future work: plug in different advanced sampling methods

\subsection{Map Learning}

% The second phase is learning the forward and reverse mapping.
% This is the main focus of the learning framework.
% Explain the forward mapping problem; give an example [figure]
% The forward mapping is a straightforward regression problem
% Assuming this is a many-to-one relationship (due to the correct definition of the measurement)

% Explain the reverse mapping problem; give an example [figure]
% The reverse mapping is an "inverted" regression problem.
% Inverted regression means f^-1 (building an inverted mapping)

% Elude that we will discuss our particular solutions to these problems in later chapters

\subsection{Using the Maps}

% Explain how the maps are queried.
% Querying the forward mapping (example)
% Querying the reverse mapping (example)

% Possible uses: prediction and control


\subsection{Summary of Configuration Points}
% Sampling methodology
% Measurements
% Forward Mapping Algorithm
% Reverse Mapping Algorithm

\section{Software Implementation Details}
% Most of the software is implemented in python, but the interaction with NetLogo is handled with Java, so that I can access the Java API.

% Give a list of agent-level variable ranges/steps
% Generate the experiments list
% Samples a NetLogo ABM with Java API, given the list of experiments, save the results
% Interact with the forward mapping regression algorithm with a python module interface
% Interact with the reverse mapping approach (discussed more in Chapter X) with a python module interface
% Different tools for selecting solutions and visualizing slices are separate python scripts.

% An overarching "master script" written in python that glues these together and automatically transitions from one to another. Each stage can be performed one by one

% More about NetLogo is covered in Background.


\section{Example: \fw Applied to Wolf Sheep Predation}

% Identification of agent-level control parameters
% Identify ranges of values for agent-level control parameters

% Definition of system-level measurements.
% Specifically how to measure them

% Choice of regression algorithm (KNN)  -- More discussion is on FM and RM

% Analysis of the accuracy of our approach against this domain is in the RESULTS chapter.

% Give a glimpse into tools -- More discussion is on using chapter


\section{Analysis of \fw  vs. the Design Goals}
% Our framework is domain independent, because it reduces the forward mapping problem to a classical regression problem of learning the correlation between the agent-level parameters and the system-level properties..
% We introduce a domain-independent approach to solve the reverse mapping problem that uses standard regression to build a space of configurations that would produce desired behavior.

% Our framework is algorithm independent, because any regression algorithm (e.g., ...) can be used to develop the forward mapping and the reverse mapping

% Our framework is as accurate as the regression algorithms used and the data set sampled from the agent-based model. /elaborate/
% In general, I prefer spending longer sampling to generate an exhaustive data set increase accuracy and reducing user interaction delays when querying for a prediction or a suggestion for controlling.
% This shifts most of the computation time offline, instead of online, reducing user interaction time when querying the forward or reverse mappings.
